# -*- mode: ruby -*-
# vi: set ft=ruby :
require 'yaml'

current_dir    = File.dirname(File.expand_path(__FILE__))
configs        = YAML.load_file("#{current_dir}/config.yaml")

Vagrant.configure(configs['VagrantConfig']['ApiVersion']) do |config|
  config.vm.box = configs['VagrantConfig']['VmBox']
  config.vm.synced_folder '.', configs['VagrantConfig']['SyncedFolder'], disabled: true
  
  config.vm.provider :virtualbox do |v|
    v.memory = configs['VmConfig']['WorkerNode']['Memory']
    v.cpus = configs['VmConfig']['WorkerNode']['Cpus']
    v.linked_clone = configs['VmConfig']['WorkerNode']['LinkedClone']
  end 

  # Virtual Machine Definintions 
  boxes = []

  configs['VmConfig']['WorkerNode']['HostConfig'].each do |item|
    boxes << { name: item['Name'], ip: item['Ip'] }
  end

  boxes.each do |opts|
    config.vm.define opts[:name] do |c|
      config.vm.hostname = opts[:name]
      config.vm.network :private_network, ip: opts[:ip]

      # Provision all the VMs in parallel using Ansible after last VM is up.
      # if opts[:name] == "kube3"
      #   config.vm.provision "ansible" do |ansible|
      #     ansible.compatibility_mode = "2.0"
      #     ansible.playbook = "main.yml"
      #     ansible.limit = "all"
      #     ansible.become = true
      #     ansible.groups = {
      #       "kubernetes" => ["kube1", "kube2", "kube3"],
      #       "kubernetes_master" => ["kube1"],
      #       "kubernetes_master:vars" => {
      #         kubernetes_role: "master",
      #         swapfile_path: "/dev/mapper/vagrant--vg-swap_1",
      #         kubernetes_apiserver_advertise_address: "192.168.56.71"
      #       },
      #       "kubernetes_node" => ["kube2", "kube3"],
      #       "kubernetes_node:vars" => {
      #         kubernetes_role: "node",
      #         swapfile_path: "/dev/mapper/vagrant--vg-swap_1"
      #       }
      #     }
      #   end
      # end 
    end
  end
end
